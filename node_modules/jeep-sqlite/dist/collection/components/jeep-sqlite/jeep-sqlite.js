import { Component, Method, Event, Prop, State, Watch } from '@stencil/core';
import { Database } from '../../utils/database';
import localForage from 'localforage';
import { isJsonSQLite } from '../../utils/utils-json';
import { saveDBToStore, isDBInStore, getDBListFromStore, removeDBFromStore } from '../../utils/utils-store';
import * as JSZip from 'jszip';
export class JeepSqlite {
  constructor() {
    this.isStore = false;
    this._dbDict = {};
    this.databaseList = {};
    this._versionUpgrades = {};
  }
  //*****************************
  //* Watch on Property Changes *
  //*****************************
  parseAutoSave(newValue) {
    this.innerAutoSave = newValue;
  }
  //**********************
  //* Method Definitions *
  //**********************
  async echo(options) {
    return options;
  }
  async createConnection(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    const version = options.version ? options.version : 1;
    try {
      await this._createConnection(dbName, version);
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async isConnection(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    const ret = await this._isConnection(dbName);
    return Promise.resolve(ret);
  }
  async closeConnection(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      await this._closeConnection(dbName);
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async open(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      await this._open(dbName);
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async close(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      await this._close(dbName);
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async getVersion(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      const res = await this._getVersion(dbName);
      return Promise.resolve(res);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async execute(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    if (!keys.includes('statements') || options.statements.length === 0) {
      return Promise.reject('Must provide raw SQL statements');
    }
    const dbName = options.database;
    const statements = options.statements;
    let transaction = true;
    if (keys.includes('transaction'))
      transaction = options.transaction;
    try {
      const changes = await this._execute(dbName, statements, transaction);
      return Promise.resolve(changes);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async executeSet(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    if (!keys.includes('set') || options.set.length === 0) {
      return Promise.reject('Must provide a non-empty set of SQL statements');
    }
    const dbName = options.database;
    const setOfStatements = options.set;
    let transaction = true;
    if (keys.includes('transaction'))
      transaction = options.transaction;
    try {
      const changes = await this._executeSet(dbName, setOfStatements, transaction);
      return Promise.resolve(changes);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async run(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    if (!keys.includes('statement') || options.statement.length === 0) {
      return Promise.reject('Must provide a run statement');
    }
    const dbName = options.database;
    const statement = options.statement;
    let values = [];
    if (keys.includes('values')) {
      values = options.values.length > 0 ? options.values : [];
    }
    let transaction = true;
    if (keys.includes('transaction'))
      transaction = options.transaction;
    try {
      const retChanges = await this._run(dbName, statement, values, transaction);
      return Promise.resolve(retChanges);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async query(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    if (!keys.includes('statement') || options.statement.length === 0) {
      return Promise.reject('Must provide a query statement');
    }
    let values = [];
    if (keys.includes('values')) {
      values = options.values.length > 0 ? options.values : [];
    }
    const dbName = options.database;
    const statement = options.statement;
    try {
      const retValues = await this._query(dbName, statement, values);
      return Promise.resolve(retValues);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async getTableList(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      const retValues = await this._getTableList(dbName);
      return Promise.resolve(retValues);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async isDBExists(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      const ret = await this._isDBExists(dbName);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async isDBOpen(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      const ret = await this._isDBOpen(dbName);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async deleteDatabase(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      return await this._deleteDatabase(dbName);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async isStoreOpen() {
    return Promise.resolve(this.isStore);
  }
  async copyFromAssets(options) {
    let overwrite;
    if (options != null) {
      const keys = Object.keys(options);
      overwrite = keys.includes('overwrite') ? options.overwrite : true;
    }
    else {
      overwrite = true;
    }
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    try {
      await this._copyFromAssets(overwrite);
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async isTableExists(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    if (!keys.includes('table')) {
      return Promise.reject('Must provide a table name');
    }
    const tableName = options.table;
    try {
      const ret = await this._isTableExists(dbName, tableName);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async createSyncTable(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      const ret = await this._createSyncTable(dbName);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async getSyncDate(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      const ret = await this._getSyncDate(dbName);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async setSyncDate(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    if (!keys.includes('syncdate')) {
      return Promise.reject('Must provide a synchronization date');
    }
    const dbName = options.database;
    const syncDate = options.syncdate;
    try {
      await this._setSyncDate(dbName, syncDate);
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async isJsonValid(options) {
    const keys = Object.keys(options);
    if (!keys.includes('jsonstring')) {
      return Promise.reject('Must provide a json object');
    }
    const jsonStrObj = options.jsonstring;
    try {
      const ret = await this._isJsonValid(jsonStrObj);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async importFromJson(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('jsonstring')) {
      return Promise.reject('Must provide a json object');
    }
    const jsonStrObj = options.jsonstring;
    try {
      const ret = await this._importFromJson(jsonStrObj);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async exportToJson(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    if (!keys.includes('jsonexportmode')) {
      return Promise.reject('Must provide a json export mode');
    }
    const dbName = options.database;
    const exportMode = options.jsonexportmode;
    try {
      const ret = await this._exportToJson(dbName, exportMode);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async deleteExportedRows(options) {
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      await this._deleteExportedRows(dbName);
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async addUpgradeStatement(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    if (!keys.includes('upgrade')) {
      return Promise.reject('Must provide an upgrade statement');
    }
    const dbName = options.database;
    const upgrade = options.upgrade[0];
    keys = Object.keys(upgrade);
    if (!keys.includes('fromVersion') ||
      !keys.includes('toVersion') ||
      !keys.includes('statement')) {
      return Promise.reject('Must provide an upgrade capSQLiteVersionUpgrade Object');
    }
    if (typeof upgrade.fromVersion != 'number') {
      return Promise.reject('ugrade.fromVersion must be a number');
    }
    const upgVDict = {};
    upgVDict[upgrade.fromVersion] = upgrade;
    this._versionUpgrades[dbName] = upgVDict;
    return Promise.resolve();
  }
  async isDatabase(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      const ret = await this._isDatabase(dbName);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async getDatabaseList() {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    try {
      const ret = await this._getDatabaseList();
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async checkConnectionsConsistency(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('dbNames')) {
      return Promise.reject(`Must provide a list of connection's name`);
    }
    const dbNames = options.dbNames;
    try {
      const ret = await this._checkConnectionsConsistency(dbNames);
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  async saveToStore(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes('database')) {
      return Promise.reject('Must provide a database name');
    }
    const dbName = options.database;
    try {
      await this._saveToStore(dbName);
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(err);
    }
  }
  //*******************************
  //* Component Lifecycle Methods *
  //*******************************
  async componentWillLoad() {
    this.isStore = await this.openStore("jeepSqliteStore", "databases");
    this.parseAutoSave(this.autoSave != undefined ? this.autoSave : false);
  }
  componentDidLoad() {
    if (!this.isStore) {
      console.log('jeep-sqlite isStore = false');
    }
  }
  //******************************
  //* Private Method Definitions *
  //******************************
  async _createConnection(database, version) {
    let upgDict = {};
    const vUpgKeys = Object.keys(this._versionUpgrades);
    if (vUpgKeys.length !== 0 && vUpgKeys.includes(database)) {
      upgDict = this._versionUpgrades[database];
    }
    try {
      const mDB = new Database(database + 'SQLite.db', version, upgDict, this.store, this.innerAutoSave);
      this._dbDict[database] = mDB;
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(err.message);
    }
  }
  async _isConnection(database) {
    const keys = Object.keys(this._dbDict);
    if (keys.includes(database)) {
      return { result: true };
    }
    else {
      return { result: false };
    }
  }
  async _closeConnection(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`CloseConnection: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      if (mDB.isDBOpen()) {
        // close the database
        try {
          await mDB.close();
        }
        catch (err) {
          return Promise.reject(`CloseConnection: close ${database} failed ${err}`);
        }
      }
      // remove the connection from dictionary
      delete this._dbDict[database];
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(`CloseConnection: ${err.message}`);
    }
  }
  async _open(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`Open: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      await mDB.open();
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(`Open: ${err.message}`);
    }
  }
  async _close(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`Close: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      await mDB.close();
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(`Close: ${err.message}`);
    }
  }
  async _saveToStore(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`SaveToStore: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      await mDB.saveToStore();
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(`SaveToStore: ${err.message}`);
    }
  }
  async _getVersion(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`Open: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      const version = await mDB.getVersion();
      const ret = {};
      ret.version = version;
      return Promise.resolve(ret);
    }
    catch (err) {
      return Promise.reject(`Open: ${err.message}`);
    }
  }
  async _execute(database, statements, transaction) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`Execute: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      const ret = await mDB.executeSQL(statements, transaction);
      const changes = { changes: { changes: ret } };
      return Promise.resolve(changes);
    }
    catch (err) {
      return Promise.reject(`Execute: ${err.message}`);
    }
  }
  async _executeSet(database, setOfStatements, transaction) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`ExecuteSet: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    for (const sStmt of setOfStatements) {
      if (!('statement' in sStmt) || !('values' in sStmt)) {
        return Promise.reject('ExecuteSet: Must provide a set as ' + 'Array of {statement,values}');
      }
    }
    try {
      const ret = await mDB.execSet(setOfStatements, transaction);
      const changes = { changes: { changes: ret.changes, lastId: ret.lastId } };
      return Promise.resolve(changes);
    }
    catch (err) {
      return Promise.reject(`ExecuteSet: ${err.message}`);
    }
  }
  async _run(database, statement, values, transaction) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`Run: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      const ret = await mDB.runSQL(statement, values, transaction);
      const changes = { changes: { changes: ret.changes, lastId: ret.lastId } };
      return Promise.resolve(changes);
    }
    catch (err) {
      return Promise.reject(`Run: ${err.message}`);
    }
  }
  async _query(database, statement, values) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`Query: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    let ret = [];
    try {
      ret = await mDB.selectSQL(statement, values);
      return Promise.resolve({ values: ret });
    }
    catch (err) {
      return Promise.reject(`Query failed: ${err.message}`);
    }
  }
  async _getTableList(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`GetTableList: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    let ret = [];
    try {
      ret = await mDB.getTableNames();
      return Promise.resolve({ values: ret });
    }
    catch (err) {
      return Promise.reject(`GetTableList failed: ${err.message}`);
    }
  }
  async _isDBExists(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`IsDBExists: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      const ret = await mDB.isDBExists(database + 'SQLite.db');
      const result = { result: ret };
      return Promise.resolve(result);
    }
    catch (err) {
      return Promise.reject(`IsDBExists: ${err.message}`);
    }
  }
  async _isDBOpen(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`IsDBOpen: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      const ret = await mDB.isDBOpen(database + 'SQLite.db');
      const result = { result: ret };
      return Promise.resolve(result);
    }
    catch (err) {
      return Promise.reject(`IsDBOpen: ${err.message}`);
    }
  }
  async _deleteDatabase(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`DeleteDatabase: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      await mDB.deleteDB(database + 'SQLite.db');
      return Promise.resolve();
    }
    catch (err) {
      return Promise.reject(`DeleteDatabase: ${err.message}`);
    }
  }
  async _isTableExists(database, table) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject(`IsTableExists: No available connection for ${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      const ret = await mDB.isTable(table);
      const result = { result: ret };
      return Promise.resolve(result);
    }
    catch (err) {
      return Promise.reject(`IsTableExists: ${err.message}`);
    }
  }
  async _createSyncTable(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject('CreateSyncTable: No available connection for ' + `${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      const ret = await mDB.createSyncTable();
      return Promise.resolve({ changes: { changes: ret } });
    }
    catch (err) {
      return Promise.reject(`CreateSyncTable: ${err.message}`);
    }
  }
  async _getSyncDate(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject('GetSyncDate: No available connection for ' + `${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      const ret = await mDB.getSyncDate();
      return Promise.resolve({ syncDate: ret });
    }
    catch (err) {
      return Promise.reject(`GetSyncDate: ${err.message}`);
    }
  }
  async _setSyncDate(database, syncDate) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject('SetSyncDate: No available connection for ' + `${database}`);
    }
    const mDB = this._dbDict[database];
    try {
      const ret = await mDB.setSyncDate(syncDate);
      if (ret.result) {
        return Promise.resolve();
      }
      else {
        return Promise.reject(`SetSyncDate: ${ret.message}`);
      }
    }
    catch (err) {
      return Promise.reject(`SetSyncDate: ${err.message}`);
    }
  }
  async _isJsonValid(jsonStrObj) {
    const jsonObj = JSON.parse(jsonStrObj);
    const isValid = await isJsonSQLite(jsonObj);
    if (!isValid) {
      return Promise.reject('IsJsonValid: Stringify Json Object not Valid');
    }
    else {
      return Promise.resolve({ result: true });
    }
  }
  async _importFromJson(jsonStrObj) {
    var _a, _b;
    const jsonObj = JSON.parse(jsonStrObj);
    const isValid = await isJsonSQLite(jsonObj);
    if (!isValid) {
      return Promise.reject('ImportFromJson: Stringify Json Object not Valid');
    }
    const vJsonObj = jsonObj;
    const dbName = `${vJsonObj.database}SQLite.db`;
    const dbVersion = (_a = vJsonObj.version) !== null && _a !== void 0 ? _a : 1;
    const mode = vJsonObj.mode;
    const overwrite = (_b = vJsonObj.overwrite) !== null && _b !== void 0 ? _b : false;
    // Create the database
    const mDb = new Database(dbName, dbVersion, {}, this.store, this.innerAutoSave);
    try {
      if (overwrite && mode === 'full') {
        const isExists = isDBInStore(dbName, this.store);
        if (isExists) {
          await removeDBFromStore(dbName, this.store);
        }
      }
      // Open the database
      await mDb.open();
      const tableList = await mDb.getTableNames();
      if (mode === 'full' && tableList.length > 0) {
        const curVersion = await mDb.getVersion();
        if (dbVersion < curVersion) {
          return Promise.reject(`ImportFromJson: Cannot import a version lower than ${curVersion}`);
        }
        if (curVersion === dbVersion) {
          return Promise.resolve({ changes: { changes: 0 } });
        }
      }
      // Import the JsonSQLite Object
      const changes = await mDb.importJson(vJsonObj, this.importProgress);
      // Close the database
      await mDb.close();
      return Promise.resolve({ changes: { changes: changes } });
    }
    catch (err) {
      return Promise.reject(`ImportFromJson: ${err.message}`);
    }
  }
  async _exportToJson(database, exportMode) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject('ExportToJson: No available connection for ' + `${database}`);
    }
    const mDb = this._dbDict[database];
    try {
      const ret = await mDb.exportJson(exportMode, this.exportProgress);
      const keys = Object.keys(ret);
      if (keys.includes('message')) {
        return Promise.reject(`ExportToJson: ${ret.message}`);
      }
      else {
        return Promise.resolve({ export: ret });
      }
    }
    catch (err) {
      return Promise.reject(`ExportToJson: ${err.message}`);
    }
  }
  async _deleteExportedRows(database) {
    const keys = Object.keys(this._dbDict);
    if (!keys.includes(database)) {
      return Promise.reject('ExportToJson: No available connection for ' + `${database}`);
    }
    const mDb = this._dbDict[database];
    try {
      await mDb.deleteExportedRows();
    }
    catch (err) {
      return Promise.reject(`DeleteExportedRows: ${err.message}`);
    }
  }
  async _copyFromAssets(overwrite) {
    const res = await this.loadJSON('assets/databases/databases.json');
    if (res != null) {
      this.databaseList = JSON.parse(res);
      const keys = Object.keys(this.databaseList);
      if (keys.includes("databaseList")) {
        try {
          for (const dbName of this.databaseList.databaseList) {
            if (dbName.substring(dbName.length - 3) === ".db") {
              await this.copyDatabase(`assets/databases/${dbName}`, overwrite);
            }
            if (dbName.substring(dbName.length - 4) === ".zip") {
              await this.unzipDatabase(`assets/databases/${dbName}`, overwrite);
            }
          }
          return Promise.resolve();
        }
        catch (err) {
          return Promise.reject(`CopyFromAssets: ${err.message}`);
        }
      }
      else {
        return Promise.reject(`CopyFromAssets: no key databaseList in databases.json`);
      }
    }
    else {
      return Promise.reject(`CopyFromAssets: no databases.json file in assets/databases folder`);
    }
  }
  async _isDatabase(database) {
    try {
      const ret = await isDBInStore(database + 'SQLite.db', this.store);
      const result = { result: ret };
      return Promise.resolve(result);
    }
    catch (err) {
      return Promise.reject(`IsDatabase: ${err.message}`);
    }
  }
  async _getDatabaseList() {
    try {
      const ret = await getDBListFromStore(this.store);
      const result = { values: ret };
      return Promise.resolve(result);
    }
    catch (err) {
      return Promise.reject(`GetDatabaseList: ${err.message}`);
    }
  }
  async _checkConnectionsConsistency(dbNames) {
    const ret = {};
    ret.result = false;
    try {
      let inConnectionsSet = new Set(Object.keys(this._dbDict));
      const outConnectionSet = new Set(dbNames);
      if (outConnectionSet.size === 0) {
        await this._resetDbDict(Object.keys(this._dbDict));
        return Promise.resolve(ret);
      }
      if (inConnectionsSet.size < outConnectionSet.size) {
        await this._resetDbDict(Object.keys(this._dbDict));
        return Promise.resolve(ret);
      }
      if (inConnectionsSet.size > outConnectionSet.size) {
        for (const key of inConnectionsSet) {
          if (!Array.from(outConnectionSet.keys()).includes(key)) {
            await this._closeConnection(key);
          }
        }
      }
      inConnectionsSet = new Set(Object.keys(this._dbDict));
      if (inConnectionsSet.size === outConnectionSet.size) {
        const symDiffSet = await this.symmetricDifference(inConnectionsSet, outConnectionSet);
        if (symDiffSet.size === 0) {
          ret.result = true;
          return Promise.resolve(ret);
        }
        else {
          await this._resetDbDict(Object.keys(this._dbDict));
          return Promise.resolve(ret);
        }
      }
      else {
        await this._resetDbDict(Object.keys(this._dbDict));
        return Promise.resolve(ret);
      }
    }
    catch (err) {
      return Promise.reject(`CheckConnectionsConsistency: ${err.message}`);
    }
  }
  async _resetDbDict(keys) {
    try {
      for (const key of keys) {
        await this._closeConnection(key);
      }
    }
    catch (err) {
      return Promise.reject(`ResetDbDict: ${err.message}`);
    }
  }
  async symmetricDifference(setA, setB) {
    let _difference = new Set(setA);
    for (const elem of setB) {
      if (_difference.has(elem)) {
        _difference.delete(elem);
      }
      else {
        _difference.add(elem);
      }
    }
    return _difference;
  }
  async unzipDatabase(dbZipName, overwrite) {
    return new Promise((resolve, reject) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', dbZipName, true);
      xhr.responseType = 'arraybuffer';
      xhr.onerror = () => {
        reject(`unzipDatabase: failed`);
      };
      xhr.onload = () => {
        try {
          JSZip.loadAsync(xhr.response).then((zip) => {
            Object.keys(zip.files).forEach((filename) => {
              zip.files[filename].async('nodebuffer').then(async (fileData) => {
                const uInt8Array = new Uint8Array(fileData);
                const dbName = this.setPathSuffix(filename);
                // check if dbName exists
                const isExist = await isDBInStore(dbName, this.store);
                if (!isExist || overwrite) {
                  if (overwrite && isExist) {
                    await removeDBFromStore(dbName, this.store);
                  }
                  await saveDBToStore(dbName, uInt8Array, this.store);
                }
              });
            });
            resolve();
          });
        }
        catch (err) {
          reject(`unzipDatabase Error: ${err}`);
        }
      };
      xhr.send();
    });
  }
  async copyDatabase(dbAssetName, overwrite) {
    return new Promise((resolve, reject) => {
      var xhr = new XMLHttpRequest();
      var uInt8Array;
      xhr.open('GET', dbAssetName, true);
      xhr.responseType = 'arraybuffer';
      xhr.onerror = () => {
        reject(`CopyDatabase: failed`);
      };
      xhr.onload = () => {
        uInt8Array = new Uint8Array(xhr.response);
      };
      xhr.onloadend = async () => {
        const dbName = this.setPathSuffix(dbAssetName);
        // check if dbName exists
        const isExist = await isDBInStore(dbName, this.store);
        if (!isExist || overwrite) {
          if (overwrite && isExist) {
            await removeDBFromStore(dbName, this.store);
          }
          await saveDBToStore(dbName, uInt8Array, this.store);
        }
        resolve();
      };
      xhr.send();
    });
  }
  async loadJSON(jsonFileName) {
    return new Promise((resolve, reject) => {
      var xobj = new XMLHttpRequest();
      xobj.overrideMimeType("application/json");
      xobj.open('GET', jsonFileName, true);
      xobj.onerror = () => {
        reject(`LoadJSON: failed`);
      };
      xobj.onreadystatechange = function () {
        if (xobj.status == 404)
          resolve(null);
        if (xobj.readyState == 4 && xobj.status == 200) {
          // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
          resolve(xobj.responseText);
        }
      };
      xobj.send(null);
    });
  }
  async openStore(dbName, tableName) {
    let ret = false;
    const config = this.setConfig(dbName, tableName);
    this.store = localForage.createInstance(config);
    if (this.store != null) {
      this.storeName = dbName;
      ret = true;
    }
    return ret;
  }
  setConfig(dbName, tableName) {
    const config = {
      name: dbName,
      storeName: tableName,
      driver: [localForage.INDEXEDDB],
      version: 1,
    };
    return config;
  }
  setPathSuffix(db) {
    let toDb = db.slice(db.lastIndexOf("/") + 1);
    const ext = ".db";
    if (db.substring(db.length - 3) === ext) {
      if (!db.includes("SQLite.db")) {
        toDb = db.slice(db.lastIndexOf("/") + 1, -3) + 'SQLite.db';
      }
    }
    return toDb;
  }
  render() {
    return;
  }
  static get is() { return "jeep-sqlite"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["jeep-sqlite.css"]
  }; }
  static get styleUrls() { return {
    "$": ["jeep-sqlite.css"]
  }; }
  static get assetsDirs() { return ["assets"]; }
  static get properties() { return {
    "autoSave": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "AutoSave"
      },
      "attribute": "autosave",
      "reflect": true
    }
  }; }
  static get states() { return {
    "innerAutoSave": {}
  }; }
  static get events() { return [{
      "method": "importProgress",
      "name": "jeepSqliteImportProgress",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": ""
      },
      "complexType": {
        "original": "JsonProgressListener",
        "resolved": "JsonProgressListener",
        "references": {
          "JsonProgressListener": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        }
      }
    }, {
      "method": "exportProgress",
      "name": "jeepSqliteExportProgress",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": ""
      },
      "complexType": {
        "original": "JsonProgressListener",
        "resolved": "JsonProgressListener",
        "references": {
          "JsonProgressListener": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        }
      }
    }]; }
  static get methods() { return {
    "echo": {
      "complexType": {
        "signature": "(options: EchoOptions) => Promise<EchoResult>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "EchoResult": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "EchoOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<EchoResult>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "createConnection": {
      "complexType": {
        "signature": "(options: ConnectionOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "ConnectionOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "isConnection": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<SQLiteResult>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteResult": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteResult>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "closeConnection": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "open": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "close": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "getVersion": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<SQLiteVersion>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteVersion": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteVersion>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "execute": {
      "complexType": {
        "signature": "(options: SQLiteExecuteOptions) => Promise<SQLiteChanges>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteChanges": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteExecuteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteChanges>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "executeSet": {
      "complexType": {
        "signature": "(options: SQLiteSetOptions) => Promise<SQLiteChanges>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteChanges": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteSetOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteSet": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteChanges>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "run": {
      "complexType": {
        "signature": "(options: SQLiteRunOptions) => Promise<SQLiteChanges>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteChanges": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteRunOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteChanges>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "query": {
      "complexType": {
        "signature": "(options: SQLiteQueryOptions) => Promise<SQLiteValues>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteValues": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteQueryOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteValues>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "getTableList": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<SQLiteValues>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteValues": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteValues>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "isDBExists": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<SQLiteResult>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteResult": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteResult>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "isDBOpen": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<SQLiteResult>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteResult": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteResult>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "deleteDatabase": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "isStoreOpen": {
      "complexType": {
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<boolean>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "copyFromAssets": {
      "complexType": {
        "signature": "(options: SQLiteFromAssetsOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteFromAssetsOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "isTableExists": {
      "complexType": {
        "signature": "(options: SQLiteTableOptions) => Promise<SQLiteResult>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteResult": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteTableOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteResult>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "createSyncTable": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<SQLiteChanges>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteChanges": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteChanges>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "getSyncDate": {
      "complexType": {
        "signature": "(options: SQLiteSyncDateOptions) => Promise<SQLiteSyncDate>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteSyncDate": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteSyncDateOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteSyncDate>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "setSyncDate": {
      "complexType": {
        "signature": "(options: SQLiteSyncDateOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteSyncDateOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "isJsonValid": {
      "complexType": {
        "signature": "(options: SQLiteImportOptions) => Promise<SQLiteResult>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteResult": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteImportOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteResult>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "importFromJson": {
      "complexType": {
        "signature": "(options: SQLiteImportOptions) => Promise<SQLiteChanges>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteChanges": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteImportOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteChanges>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "exportToJson": {
      "complexType": {
        "signature": "(options: SQLiteExportOptions) => Promise<SQLiteJson>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteJson": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteExportOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteJson>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "deleteExportedRows": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "addUpgradeStatement": {
      "complexType": {
        "signature": "(options: SQLiteUpgradeOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteUpgradeOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "Record": {
            "location": "global"
          },
          "SQLiteVersionUpgrade": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "isDatabase": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<SQLiteResult>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteResult": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteResult>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "getDatabaseList": {
      "complexType": {
        "signature": "() => Promise<SQLiteValues>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteValues": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteValues>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "checkConnectionsConsistency": {
      "complexType": {
        "signature": "(options: AllConnectionsOptions) => Promise<SQLiteResult>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteResult": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          },
          "AllConnectionsOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<SQLiteResult>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    },
    "saveToStore": {
      "complexType": {
        "signature": "(options: SQLiteOptions) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          },
          "SQLiteOptions": {
            "location": "import",
            "path": "../../interfaces/interfaces"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    }
  }; }
  static get watchers() { return [{
      "propName": "autoSave",
      "methodName": "parseAutoSave"
    }]; }
}
//# sourceMappingURL=jeep-sqlite.js.map