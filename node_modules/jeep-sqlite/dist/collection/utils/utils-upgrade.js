import { setForeignKeyConstraintsEnabled, dbChanges, backupTables, execute, executeSet, findCommonColumns, updateNewTablesData, setVersion, isTableExists } from '../utils/utils-sqlite';
import { copyDBToStore, setDBToStore } from './utils-store';
import { dropElements, dropTempTables } from './utils-drop';
export const onUpgrade = async (mDb, vUpgDict, dbName, curVersion, targetVersion, store) => {
  let changes = -1;
  const upgrade = vUpgDict[curVersion];
  if (upgrade != null) {
    const keys = Object.keys(upgrade);
    if (!keys.includes('toVersion')) {
      return Promise.reject(new Error('onUpgrade: toVersion not given'));
    }
    const toVersion = upgrade.toVersion;
    if (!keys.includes('statement')) {
      return Promise.reject(new Error('onUpgrade: statement not given'));
    }
    const statement = upgrade.statement;
    let set = [];
    if (keys.includes('set')) {
      set = upgrade.set;
    }
    if (targetVersion < toVersion) {
      let msg = 'Error: version mistmatch ';
      msg += 'Upgrade Statement would upgrade to ';
      msg += `version ${toVersion} , but target version `;
      msg += `is ${targetVersion} for database ${dbName}`;
      msg += ` and version ${curVersion}`;
      return Promise.reject(new Error(`onUpgrade: ${msg}`));
    }
    try {
      // set Foreign Keys Off
      await setForeignKeyConstraintsEnabled(mDb, false);
      // copy the db
      await copyDBToStore(dbName, `backup-${dbName}`, store);
      const initChanges = await dbChanges(mDb);
      // Here we assume that all table schemas are given
      // in the upgrade statement
      if (statement.length > 0) {
        await executeStatementProcess(mDb, statement);
        // save the database to store
        await setDBToStore(mDb, dbName, store);
        // Here we assume that the Set contains only
        // - the data for new tables
        //   as INSERT statements
        // - the data for new columns in existing tables
        //   as UPDATE statements
        if (set.length > 0) {
          await executeSetProcess(mDb, set, toVersion);
          // save the database to store
          await setDBToStore(mDb, dbName, store);
        }
      }
      // set Foreign Keys On
      await setForeignKeyConstraintsEnabled(mDb, true);
      changes = (await dbChanges(mDb)) - initChanges;
      // save the database to store
      await setDBToStore(mDb, dbName, store);
      return Promise.resolve(changes);
    }
    catch (err) {
      return Promise.reject(new Error(`onUpgrade: ${err.message}`));
    }
  }
  else {
    return Promise.reject(new Error('onUpgrade: upgrade not found'));
  }
};
export const executeStatementProcess = async (mDb, statement) => {
  let alterTables = {};
  let commonColumns = {};
  try {
    // -> backup all existing tables  "tableName" in
    //    "temp_tableName"
    alterTables = await backupTables(mDb);
    // -> Drop all Indexes
    await dropElements(mDb, 'index');
    // -> Drop all Triggers
    await dropElements(mDb, 'trigger');
    // -> Create new tables from upgrade.statement
    const changes = await execute(mDb, statement, false);
    if (changes < 0) {
      return Promise.reject(new Error('ExecuteStatementProcess: ' + 'changes < 0'));
    }
    // -> Create the list of table's common fields
    commonColumns = await findCommonColumns(mDb, alterTables);
    // -> Update the new table's data from old table's data
    if (Object.keys(commonColumns).length > 0) {
      await updateNewTablesData(mDb, commonColumns);
    }
    return Promise.resolve();
  }
  catch (err) {
    return Promise.reject(new Error(`ExecuteStatementProcess: ${err.message}`));
  }
  finally {
    // -> Drop _temp_tables
    await dropTempTables(mDb, alterTables);
    // -> Do some cleanup
    alterTables = {};
    commonColumns = {};
  }
};
export const executeSetProcess = async (mDb, set, toVersion) => {
  try {
    // -> load new data
    const lastId = await executeSet(mDb, set, false);
    if (lastId < 0) {
      return Promise.reject(new Error('ExecuteSetProcess: lastId ' + '< 0'));
    }
    // -> update database version
    await setVersion(mDb, toVersion);
    // -> update syncDate if any
    const retB = await isTableExists(mDb, 'sync_table');
    if (retB) {
      const sDate = Math.round(new Date().getTime() / 1000);
      let stmt = 'UPDATE sync_table SET ';
      stmt += `sync_date = ${sDate} WHERE id = 1;`;
      const changes = await execute(mDb, stmt, false);
      if (changes < 0) {
        return Promise.reject(new Error('ExecuteSetProcess: changes ' + '< 0'));
      }
    }
    return Promise.resolve();
  }
  catch (err) {
    return Promise.reject(new Error(`ExecuteSetProcess: ${err.message}`));
  }
};
//# sourceMappingURL=utils-upgrade.js.map